#pragma once
#include "stateController.h"
#include "raygui.h"

class Engine
{
public:
    Engine() = default;
    void init();
    void startGame();

private:
    stateController state_controller;
    void m_KeyboardInput();
};
#pragma once
#include "../include/raylib.h"
#include "../include/raymath.h"
#include <cassert>

class Entity
{
public:
    Entity(Vector2 position_);
    Vector2 getPosition() const;
    Entity &setPosition(const Vector2 &pos);

private:
    Vector2 position;
};#pragma once

#include "../include/raylib.h"
#include "../headers/entity.h"
#include "../headers/snake.h"
#include <iostream>
#include <vector>

#define WIDTH 900
#define HEIGHT 600
#define CELL 30
#define WINDOW_HEIGHT 800

class Snake;
class Render
{
public:
    Render();
    void DrawEntity(Entity &e);
    void DrawSnake(const Snake &s);
    void DrawGameBoard();

    void DrawCollectable(const Vector2 &pos);

    // TODO : Draw Textures of COLLECTABLES

    ~Render();

    void LoadCollectableTexture();

private:
    std::unique_ptr<Texture2D> texture;
};
#pragma once
#include "entity.h"
#include <memory>
#include <vector>
#include <deque>

using Body = std::deque<std::shared_ptr<Entity>>;

class Snake
{
public:
    Snake();
    void increaseSize();
    void initialState();
    const Body &getBody() const;
    int getSnakeLength() const;

    void setBody(Body newBody);

private:
    Body m_body;
};#pragma once
#include "state.h"
#include "uiStates.h"
#include "stack"

using myStates = std::unique_ptr<State>;

// GAME STATE IDENTIFICATION //
// Play State --> 1
// Main Menu --> 2
// Game Over --> 3

class stateController
{
public:
    stateController();
    int get_current_state();
    void add_new_state(int state_flag);
    void pop_state();
    void change_state(int state_flag);
    void init();
    void run_current_state();

private:
    std::stack<myStates> state_container;
};#pragma once
#include "../headers/entity.h"
#include "../headers/snake.h"
#include "../headers/render.h"
#include <iostream>

enum Direction
{
    LEFT,
    RIGHT,
    UP,
    DOWN
};
//  FINITE STATE MACHINE //

// PURE ABSTARCT CLASS TO MANAGE GAME STATES
class State
{

public:
    State() = default;
    virtual void m_Render() = 0;
    virtual void m_Update() = 0;
    virtual void m_KeyboardInput() = 0;
    virtual int getStateIdentifier() const = 0;
    virtual ~State() = 0;
};

inline State::~State() {}

class PlayState : public State
{
private:
    int current_score;
    std::shared_ptr<Snake> m_snake;
    std::shared_ptr<Entity> m_snakeHead;
    std::vector<Vector2> m_collectables;
    Render render;

    int targetFrames;
    int counterFrames;
    Direction dir;
    // COLLISION DETECTION//
    bool checkCollision();
    bool bodyCollision();
    bool wallCollision();

    // SNAKE  MOVEMENT //
    Vector2 nextHeadPos();
    void updateSnake();
    void movePerFrame();

    std::shared_ptr<Entity> get_head();

    void ScoreUI();

    Vector2 randomCollectablePosition();

public:
    PlayState();

    void m_Render() override; // Renders Snake , Board , Score UI
    void m_Update() override; // Play State Loop
    void m_KeyboardInput() override;
    void setTargetFrames(int val);
    int getStateIdentifier() const override;
    bool game_over; // Game over flag
};
#pragma once
#include "../include/raylib.h"
#include "state.h"

class UIUtils
{

public:
    UIUtils() = default;
    int MessageBox(float Width, float Height, Vector2 position,
                   const char *title, const char *message, const char *buttons);

    bool Button(float Width, float Height, Vector2 pos, const char *title);
    int test();
};

class UIMenuState : public State
{
private:
    UIUtils ui;

    int RenderMainMenu();

public:
    UIMenuState() = default;
    void m_Update() override;
    void m_Render() override;
    void m_KeyboardInput() override;
    int getStateIdentifier() const override;
};

class UIGameOverState : public State
{
private:
    UIUtils ui;
    int RenderGameOverMenu();

public:
    UIGameOverState() = default;
    void m_Update() override;
    void m_Render() override;
    void m_KeyboardInput() override;
    int getStateIdentifier() const override;
};#include "../headers/entity.h"

Entity::Entity(Vector2 position_) : position(position_) {}

Vector2 Entity::getPosition() const
{
    return position;
}

Entity &Entity::setPosition(const Vector2 &pos)
{
    this->position = pos;
    return *this;
}#include "../headers/render.h"

Render::Render()
{
    LoadCollectableTexture();
}

void Render::LoadCollectableTexture()
{

    if (!texture)
    {
        std::cout << "Already loaded\n";
        return;
    }
    const char *path = "./Assets/textures/heart.png";
    if (!FileExists(path))
    {
        std::cerr << "This file doesn't exist\n";
        return;
    }

    Image image = LoadImage(path);
    if (image.data == nullptr)
    {
        std::cerr << "Failed to load image data\n";
        return;
    }

    ImageResize(&image, CELL, CELL);
    texture = std::make_unique<Texture2D>(LoadTextureFromImage(image));

    if (texture->id == 0)
    {
        std::cerr << "\n\nFailed to load the texture!!\n";
        UnloadImage(image);
        return;
    }

    UnloadImage(image);
}
void Render::DrawGameBoard()
{
    int k = 0;
    for (int i = 0; i < HEIGHT; i += CELL)
    {
        DrawLine(0, i, WIDTH, i, DARKGREEN);
    }
    // Draw Vertical Lines
    for (int i = 0; i < WIDTH; i += CELL)
    {
        DrawLine(i, 0, i, HEIGHT, DARKGREEN);
    }

    // Drawing the border of the window
    DrawLine(0, HEIGHT, WIDTH, HEIGHT, DARKGREEN);
}

void Render::DrawEntity(Entity &e)
{
    Vector2 position = e.getPosition();
    DrawRectangle(position.x, position.y, CELL, CELL, GREEN);
    DrawRectangleLines(position.x, position.y, CELL, CELL, BLACK);
}

void Render::DrawSnake(const Snake &s)
{
    for (auto &i : s.getBody())
    {
        DrawEntity(*i);
    }
}

void Render::DrawCollectable(const Vector2 &pos)
{
    if (texture)
        DrawTexture(*texture, pos.x, pos.y, WHITE);
}
Render::~Render()
{
    if (texture)
        UnloadTexture(*texture);
}#include "../headers/snake.h"

Snake::Snake()
{

    initialState();
}

void Snake::initialState()
{
    if (!m_body.empty())
    {
        m_body.clear();
    }

    std::vector<Vector2> initialpositions = {Vector2{30.0f, 30.0f},
                                             Vector2{60.0f, 30.0f},
                                             Vector2{90.0f, 30.0f}};

    m_body.emplace_back(std::make_shared<Entity>(initialpositions[0]));
    m_body.emplace_back(std::make_shared<Entity>(initialpositions[1]));
    m_body.emplace_back(std::make_shared<Entity>(initialpositions[2]));
}

const Body &Snake::getBody() const
{
    return m_body;
}

void Snake::increaseSize()
{
    Vector2 lastSegment = m_body.back()->getPosition();
    Vector2 secondLastSegment = m_body[m_body.size() - 2]->getPosition();
    Vector2 direction = Vector2Subtract(lastSegment, secondLastSegment);
    Vector2 newpos = Vector2Add(lastSegment, direction);
    std::shared_ptr<Entity> newSegement = std::make_shared<Entity>(newpos);
    m_body.emplace_back(newSegement);
}

int Snake::getSnakeLength() const
{
    return m_body.size();
}

void Snake::setBody(Body newBody)
{
    m_body = std::move(newBody);
}#include "../headers/stateController.h"

stateController::stateController()
{
    init();
}
void stateController::init()
{
    add_new_state(2);
}
int stateController::get_current_state()
{
    return state_container.top()->getStateIdentifier();
}

void stateController::add_new_state(int state_flag)
{
    myStates new_state;
    if (state_flag == 1)
        new_state = std::make_unique<PlayState>();
    else if (state_flag == 2)
        new_state = std::make_unique<UIMenuState>();
    else if (state_flag == 3)
        new_state = std::make_unique<UIGameOverState>();

    state_container.push(new_state);
}

void stateController::pop_state()
{
    if (!state_container.empty())
        state_container.pop();
}

void stateController::change_state(int state_flag)
{
    pop_state();
    add_new_state(state_flag);
}

void stateController::run_current_state()
{
    int current_state_flag = get_current_state();
    myStates current_state;
    if (current_state_flag == 1)
        current_state = std::make_unique<PlayState>();
    else if (current_state_flag == 2)
        current_state = std::make_unique<UIMenuState>();
    else if (current_state_flag == 3)
        current_state = std::make_unique<UIGameOverState>();

    current_state->m_Update();
}#include "../headers/state.h"

#define NORMAL_SPEED 150
#define HIGH_SPEED 100

PlayState::PlayState() : targetFrames(NORMAL_SPEED), dir(RIGHT), counterFrames(0), current_score(0), game_over(false)
{

    m_snake = std::make_shared<Snake>();
    m_snakeHead = get_head();
}

//=======================================HELPER FUNCTION==================================//

std::shared_ptr<Entity> PlayState::get_head()
{
    return m_snake->getBody().front();
}

// ======================================= COLLISION DETECTION ==========================//

bool PlayState::checkCollision()
{
    return bodyCollision() || wallCollision();
}

bool PlayState::bodyCollision()
{
    const int current_length = m_snake->getSnakeLength();
    if (current_length == 3)
        return false;

    for (size_t i = 1; i < m_snake->getSnakeLength(); ++i)
    {
        if (m_snakeHead->getPosition() == m_snake->getBody()[i]->getPosition())
        {
            return true;
        }
    }

    return false;
}

bool PlayState::wallCollision()
{
    m_snakeHead = get_head();
    Vector2 head_pos = m_snakeHead->getPosition();

    if (head_pos.x < 0 || head_pos.x + CELL > WIDTH)
        return true;
    else if (head_pos.y < 0 || head_pos.y + CELL > HEIGHT)
        return true;
    return false;
}

// ========================================= Handle Keyboard Inputs ============================//

void PlayState::m_KeyboardInput()
{
    if (IsKeyPressed(KEY_RIGHT) && dir != LEFT)
        dir = RIGHT;
    else if (IsKeyPressed(KEY_LEFT) && dir != RIGHT)
        dir = LEFT;
    else if (IsKeyPressed(KEY_UP) && dir != DOWN)
        dir = UP;
    else if (IsKeyPressed(KEY_DOWN) && dir != UP)
        dir = DOWN;
    else if (IsKeyDown(KEY_LEFT_SHIFT))
        setTargetFrames(HIGH_SPEED);
    else if (IsKeyReleased(KEY_LEFT_SHIFT))
        setTargetFrames(NORMAL_SPEED);
    // else if (IsKeyPressed(KEY_P))
    // {
    //     this->current_score++;
    // }
}
//========================================== MOVEMENT ==========================================//
void PlayState::movePerFrame()
{
    if (counterFrames >= targetFrames)
    {
        updateSnake();
        counterFrames = 0;
    }
    else
    {

        counterFrames++;
    }
}

void PlayState::setTargetFrames(int val)
{
    this->targetFrames = val;
}

Vector2 PlayState::nextHeadPos()
{
    m_snakeHead = get_head();
    Vector2 currentPos = m_snakeHead->getPosition();
    if (dir == RIGHT)
        return Vector2Add(currentPos, Vector2{CELL, 0});
    else if (dir == LEFT)
        return Vector2Add(currentPos, Vector2{-CELL, 0});
    else if (dir == UP)
        return Vector2Add(currentPos, Vector2{0, -CELL});
    else
        return Vector2Add(currentPos, Vector2{0, CELL});
}

// TODO SNAKE MOVEMENT

void PlayState::updateSnake()
{
    if (checkCollision())
    {
        std::cout << "You LOST at pos " << m_snakeHead->getPosition().x << ' ' << m_snakeHead->getPosition().y << "\n";
        this->current_score = 0;
        game_over = true;
    }
    std::shared_ptr<Entity> tail = m_snake->getBody().back();
    Vector2 tailPos = tail->getPosition();

    tail->setPosition(nextHeadPos());
    Body new_body = m_snake->getBody();
    new_body.push_front(tail);
    new_body.pop_back();
    m_snake->setBody(new_body);
}

void PlayState::m_Render()
{
    //  Render the Game board
    render.DrawGameBoard();

    // Render the Snake
    render.DrawSnake(*m_snake);

    if (m_collectables.empty())
    {
        Vector2 collectable_position = randomCollectablePosition();
        m_collectables.push_back(collectable_position);
    }
    for (auto const &i : m_collectables)
    {

        render.DrawCollectable(i);
    }

    // TODO Render the collectables
    // TODO Render UI Score board
}

void PlayState::m_Update()
{

    if (game_over)
        return;
    m_KeyboardInput();
    movePerFrame();
    m_Render();
    ScoreUI();
}

void PlayState::ScoreUI()
{

    int score = this->current_score;
    std::string scoreText = std::to_string(score);

    DrawText("Score", 20, 700, 40, RED);
    DrawText(scoreText.c_str(), 200, 700, 40, ORANGE);
}

Vector2 PlayState::randomCollectablePosition()
{
    float posx = (float)GetRandomValue(0, WIDTH - CELL);
    float posy = (float)GetRandomValue(0, HEIGHT - CELL);

    std::cout << "\n\nCollectable Position: " << posx << ' ' << posy << '\n';
    return Vector2{posx, posy};
}

int PlayState::getStateIdentifier() const { return 1; }#define RAYGUI_IMPLEMENTATION
#include "../include/raygui.h"
#include "../headers/uiStates.h"

int UIUtils::MessageBox(float Width, float Height,
                        Vector2 position, const char *title, const char *message, const char *buttons)
{

    GuiLoadStyle("./Styles/style_terminal.rgs");
    return GuiMessageBox((Rectangle){position.x, position.y, (float)Width, (float)Height}, title,

                         message, buttons);
}

bool UIUtils::Button(float Width, float Height, Vector2 pos, const char *title)
{
    GuiLoadStyle("./Styles/style_terminal.rgs");
    return GuiButton((Rectangle){pos.x, pos.y, Width, Height}, title);
}

int UIUtils::test()
{

    if (GuiWindowBox((Rectangle){200, 100, 500, 500}, "You Lost"))
        return 1;

    DrawText("Game Over", 350, 300, 40, RED);
    if (GuiButton((Rectangle){250, 500, 150, 40}, "Restart"))
        return 2;
    // Render Button 2: Exit
    if (GuiButton((Rectangle){550, 500, 100, 40}, "Exit"))
        return 3;

    return -1;
}
// ===================================== MAIN MENU STATE ================================ //

int UIMenuState::RenderMainMenu()
{
    // TODO Render a Background

    // Render Window Box
    GuiLoadStyle("./Styles/style_terminal.rgs");
    GuiSetStyle(DEFAULT, TEXT_SIZE, 40);
    if (GuiWindowBox((Rectangle){0, 0, WIDTH, WINDOW_HEIGHT}, ""))
        return 1;

    DrawText("Snake", 350, 200, 70, GREEN);
    // Render Button 1 : Play
    if (GuiButton((Rectangle){350, 450, 200, 70}, "Play"))
        return 2;
    // Render Button 2: Exit
    if (GuiButton((Rectangle){350, 550, 200, 70}, "Exit"))
        return 3;

    return -1;

    // Render Text Box with "Snake game"

    // Render Button 1 : Play

    // Render Button 2: Exit
}

void UIMenuState::m_Render()
{
    RenderMainMenu();
}

void UIMenuState::m_Update()
{
    m_KeyboardInput();
    m_Render();
}

void UIMenuState::m_KeyboardInput() {}

int UIMenuState::getStateIdentifier() const { return 2; }
/////////////////////////////////////////////////////////////////////////////////////

int UIGameOverState::RenderGameOverMenu()
{

    GuiLoadStyle("./Styles/style_terminal.rgs");
    if (GuiWindowBox((Rectangle){0, 0, 500, 500}, "You Lost"))
        return 1;

    if (GuiButton((Rectangle){100, 450, 200, 70}, "Restart"))
        return 2;
    // Render Button 2: Exit
    if (GuiButton((Rectangle){150, 450, 200, 70}, "Exit"))
        return 3;

    return -1;
}

void UIGameOverState::m_KeyboardInput() {}
void UIGameOverState::m_Render()
{

    RenderGameOverMenu();
}

void UIGameOverState::m_Update()
{
    m_KeyboardInput();
    m_Render();
}
int UIGameOverState::getStateIdentifier() const { return 3; }